# **osm-router**
A simple router for OpenStreetMap written in TypeScript. Heavily inspired by [OSRM](https://project-osrm.org/).

This is **not** meant to be a standalone routing engine, as there exist much more sophisticated routing engines written in much faster languages like [OSRM](https://project-osrm.org/), [GraphHopper](https://www.graphhopper.com/) and [Valhalla](https://valhalla.github.io/valhalla/) to mention a few. 

This is instead meant to be a router for augmenting and modifying routes generated by those standalone engines without having to modify those very optimized and complicated routing engines yourself.

As such it does not feature any kind of graph augmentation like *Contraction Hierarchies* or *Multilevel Djikstras*, as they do not allow for arbitrary dynamic cost functions. The routing therefore is pretty slow, especially if you use a complicated dynamic cost function, which is what this was built for. On my machine 10 kilometers is around the limit for acceptable performance.

# **Usage**

## Routing Engine
The engine currently features 2 routing algorithms, *Djikstras* and *Bidirectional djikstras*.

Both of them can be augmented with an arbitrary cost function **per route**.

Shown here with the two examples from the demo, one avoids the circle, and one is required to pass through it.

![Demo Showcase](./docs/assets/demo_showcase.gif)

For instructions on how to play around with the demo on your machine, see `docs/demo.md`

## Preprocessing Pipeline
Like those optimized routing engines, this one also relies on a preprocessing pipeline to create a routable graph from OpenStreetMap data.
This preprocessing pipeline has the same `processNode`, `processWay` & `processTurn` pipeline stages as OSRM.

Do not expect to be able to get this running with `planet.osm.pbf`, the main bottleneck currently is that the JavaScript `Map` is bounded to a maximum of `2^24 (16.777.216)` entries ([source](https://stackoverflow.com/a/54466812)), which limits the amount of nodes that can be loaded.

For a full demonstration of how to use this and more, check out `src/demo/preprocess.ts`.

Here is a simplified example. 

```ts
import { OSMData, Utils } from 'osm-router'

// Loading an osm.pbf file
const data = new OSMData()

await data.read("./example.osm.pbf")

// Preprocessing OSM Nodes.
data.process("node", (node, relations, data) => {
    if(node.tags?.barrier) {
        return false
    }
    return true
})

// Preprocessing OSM Ways.
data.process("way", (way, relations, data) => {
    const maxSpeedString = way.tags?.maxspeed
    if(!maxSpeedString) { return true }
    const maxSpeed = parseFloat(maxSpeedString)
    if(!isNan(maxSpeed)) {
        way.speed.forward = maxSpeed
        way.speed.backward = maxSpeed
    }
    return true
})

// Building the routing graph.
const graph = data.build((turn, junction, data) => {
    if(Math.abs(turn.angle) > 135) {
        return 20
    }
    return 0
})

// Serializing the routing graph.
const serialized = await graph.serialize()
await writeFile("./graph.bin", serialized.out)

```

The resulting file is in a custom binary format. For more information on it see `docs/fileformat.md`.

# **API**

# OSMData(options?)
Returns a new `OSMData` instance which is an `EventEmitter` subclass.

## Options
Type: `object`

### filter
Type: `Function`

Filter function that will be called when reading in elements from an `osm.pbf` file.

For an example see `src/demo/preprocess.ts`

# OSMData instance

## **.read(path)**
Read in all elements from an `osm.pbf` file and returns a promise which resolves when it is finished.

### path
The path to the `osm.pbf` file.

## **.process(type, handler)**
Process a specific type of OSM Element

### type
type: `"node" | "way" | "relation"`

The type of element to process

### handler
type: `Function`

The function responsible for processing the type of element selected with the `type` parameter.
To process the element, the function is expected to mutate it, while still conforming to the element type.
If the handler returns a falsy value, the element will be discarded and not used to build the final graph.

See the **Processing elements** section for details.

## **.build(processTurn?)**
Build the routable graph from the OpenStreetMap that have been read and processed so far.
Should be called after reading in an `.osm.pbf` file and processing it with `.process`.

### processTurn
type: `Function`

The function responsible for assigning costs to each turn in the graph. 
If the handler returns `undefined`, the turn is discarded and the final graph will not contain it. 
See the **Graph Structure** section for more details.

## **.getObstacles(way, from, to)**
Retrieve obstacles from all nodes on `way` between the nodes `from` and `to`.

The nodes of the `way` are always traversed in the direction that they are defined in the OSM extract, and the order of the `from` and `to` dictate which obstacles are filtered out based on their `direction`.

The nodes checked exclude the first node encountered, whether that be `to` or `from`, but does include the last node encountered, whether that be `to` or `from`.

For more details on the return type see the **Obstacles** section.

### way
type: `Way`

### from
type: `Node`

### to
type: `Node`

## **.nodes**
## **.ways**
## **.relations**
Maps from OSM Id to object representations.

## **.nodeToWayMap**
A map from nodes the the ways that they are part of. In most cases this will only be 1 way, but in intersections it may be more.

## **.elementToRelationMap**
A map from OSM Id to relations that they are part of.

# **Graph Structure**
The graph structure is heavily inspired by OSRM, and they have a great article about edge-expanded graphs on their [wiki](https://github.com/Project-OSRM/osrm-backend/wiki/Graph-representation). **osm-router** essentially uses the same edge-expanded graph under the hood as OSRM. This is also where the `processTurn` function in the `.build` method has an influence. When the cost of each edge is calculated in the edge-expanded graph, the final weight of the expanded edge becomes the cost of the edge that the turn starts from plus the cost of the turn, which is provided by the `processTurn` function.

# **Processing elements**
There are three processing steps in the preprocessing pipeline.

These are here for convenience, but the entire graph is accessible on the `OSMData` object if some custom pre processing is necessary for your usecase.

## Nodes
When processing nodes the intended way to handle them is to use **Obstacles**. These are a piece of data associated with a node. They are not factored in automatically, and you are responsible for factoring them in when building the graph via the `processTurn` function.

### **Obstacles**
Obstacles are defined by three fields:

### duration
The expected delay from this obstacle in seconds. `undefined` is also allowed.

### type
There is a select amount of types that an obstacle can be of. The current list is:
- none
- barrier
- traffic_signals
- stop
- stop_minor
- give_way
- crossing
- traffic_calming
- mini_roundabout
- turning_loop
- turning_circle

These can be used to provide custom defaults for obstacle with `undefined` durations if you wish.

### direction
The direction with respect to the underlying way that the obstacle is active. There are 4 allowed directions:
- none
- forward
- backward
- both
The direction of the obstacle is factored in when using the `.getObstacles` method.

Obstacles on a specific node are accessible via the `.obstacles` field.

## Ways
When processing ways, there are 4 fields that can be modified. All of them can be modified in both directions.

### speed
The speed 