# **osm-router**
A simple router for OpenStreetMap written in TypeScript.

This is **not** meant to be a standalone routing engine, as there exist much more sophisticated routing engines written in much faster languages like [OSRM](https://project-osrm.org/), [GraphHopper](https://www.graphhopper.com/) and [Valhalla](https://valhalla.github.io/valhalla/) to mention a few. 

This is instead meant to be a router for augmenting and modifying routes generated by those standalone engines without having to modify those very optimized and complicated routing engines yourself.

As such it does not feature any kind of graph augmentation like *Contraction Hierarchies* or *Multilevel Djikstras*, as they do not allow for arbitrary dynamic cost functions. The routing therefore is pretty slow, especially if you use a complicated dynamic cost function, which is what this was built for. 10 kilometers is around the limit for acceptable performance.

# The Parts

## Routing Engine
The engine currently features 2 routing algorithms, *Djikstras* and *Bidirectional djikstras*.

Both of them can be augmented with an arbitrary cost function **per route**.

Shown here with the two examples from the demo, one avoids the circle, and one is required to pass through it.

![Demo Showcase](./docs/assets/demo_showcase.gif)

## Preprocessing Pipeline
Like those optimized routing engines, this one also relies on a preprocessing pipeline to create a routable graph from OpenStreetMap data.
This preprocessing pipeline is inspired by OSRM, and has the same `processNode`, `processWay` & `processTurn` pipeline stages.

Do not expect to be able to get this running with `planet.osm.pbf`, the main bottleneck currently is that the JavaScript `Map` is bounded to a maximum of `2^24 (16.777.216)` entries ([source](https://stackoverflow.com/a/54466812)), which limits the amount of nodes that can be loaded.

For a full demonstration of how to use this and more, check out `./src/demo`.

Here is a simplified example. 

```ts
import { OSMData, Utils } from 'osm-router'

// Loading an osm.pbf file
const data = new OSMData()

await data.read("./example.osm.pbf")

// Preprocessing OSM Nodes.
data.process("node", (node, relations, data) => {
    const barrier = Utils.getTag(node, "barrier")
    if(barrier) {
        return false
    }
    return true
})

// Preprocessing OSM Ways.
data.process("way", (way, relations, data) => {
    const maxSpeedString = Utils.getTag(way, "maxspeed")
    if(!maxSpeedString) { return true }
    const maxSpeed = parseFloat(maxSpeedString)
    if(!isNan(maxSpeed)) {
        way.speed.forward = maxSpeed
        way.speed.backward = maxSpeed
    }
    return true
})

// Building the routing graph.
const graph = data.build((turn, junction, data) => {
    if(Math.abs(turn.angle) > 135) {
        return 20
    }
    return 0
})

// Serializing the routing graph.
const serialized = await graph.serialize()
await writeFile("./graph.bin", serialized.out)

```

The resulting file is in a custom binary format. For more information check out `docs/fileformat.md`.